var that;
var db;
var action = '';

function parseReleaseDate(input, title) {
	var date = false;
	
	if (input.match(/^\d{4}\-\d{2}\-\d{2}$/)) {
		date = input;
	}
	
	if (!date) {
		that.write('Improper date for "' + title + '": ' + input);
		that.write('Enter date as YYYY-MM-DD');
		
		process.stdin.resume();
		var response = fs.readSync(process.stdin.fd, 100, 0, "utf8")[0];
		process.stdin.pause();
		
		response = response.replace(/^\s*/, '').replace(/\s*$/, '');
		
		date = parseReleaseDate(response, title);
	}
	
	return date;
}

function MyFavoriteMovies(options) {
	EventEmitter.call(this);
	
	that = this;
	
	if (typeof(options.db) !== 'undefined') {
		db = options.db;
	} else {
		db = new DB();
	}
	
	db.on('ready', that.init);
}

util.inherits(MyFavoriteMovies, EventEmitter);

MyFavoriteMovies.prototype.usage = 'usage: index.js <command> [parameters]';
MyFavoriteMovies.prototype.help = 'Type "index.js help" for more information.';
MyFavoriteMovies.prototype.rateDeviation = 15;

MyFavoriteMovies.prototype.write = function (msg) {
	process.stdout.write(msg + '\n');
}

MyFavoriteMovies.prototype.init = function () {
	if (typeof(process.argv[2]) !== 'undefined') {
		action = process.argv[2];
		
		switch(action) {
			case 'help':
				that.write(that.usage);
				that.write('');
				that.write('help\tshows this list');
				that.write('import\t[relative_path] parses an IMDB export CSV file and imports it into the database.');
				that.write('rate\tasks you to choose the better one out of two movies');
				
				that.exit();
				
				break;
			case 'import':
				if (typeof(process.argv[3]) !== 'undefined') {
					that.import(process.argv[3]);
				} else {
					that.write('The "import" command requires a parameter, which should be the relative path to the CSV file to be imported.');
					that.write('usage: index.js import "path/to/file.csv"');
					
					that.exit();
				}
				
				break;
			case 'rate':
				// TODO: check asynchronous behavior
				
				var clauses = {};
				clauses.order = { by: 'rand' };
				clauses.limit = 1;
				
				db.select('movies', clauses, function (rows, fields) {
					var movieOne = new Movie(rows[0]);
					
					var clauses = {};
					clauses.order = { by: 'rand' };
					clauses.where = { rating: [movieOne.rating - that.rateDeviation, movieOne.rating + that.rateDeviation] }; // TODO: NOT IN movieOne
					clauses.limit = 1;
					
					db.select('movies', clauses, function (rows, fields) {
						var movieTwo = new Movie(rows[0]);
						
						console.log("\n1. " + movieOne.title + "\n2. " + movieTwo.title + "\n3. Skip\n4. Exit");
						
						process.stdin.resume();
						var response = fs.readSync(process.stdin.fd, 100, 0, "utf8")[0];
						process.stdin.pause();
						
						response = parseInt(response);
						
						switch (response) {
							case 1:
								movieOne.rating = Math.min(movieOne.rating + 1, 100);
								movieTwo.rating = Math.max(movieTwo.rating - 1, 0);
								break;
							case 2:
								movieOne.rating = Math.max(movieOne.rating - 1, 0);
								movieTwo.rating = Math.min(movieTwo.rating + 1, 100);
								break;
							case 4:
								that.exit();
								break;
						}
						
						db.update('movies', { update: { rating: movieOne.rating }, where: { id: movieOne.id } });
						db.update('movies', { update: { rating: movieTwo.rating }, where: { id: movieTwo.id } });
						
						that.init();
					});
				});
				
				break;
			default:
				that.write(process.argv[2] + ' is not a supported action.');
				that.write(that.help);
				that.write(that.usage);
				
				that.exit();
				
				break;
		}
	} else {
		that.write('Action must be specified.');
		that.write(that.help);
	}
}

MyFavoriteMovies.prototype.import = function (path) {
	var importQueue = 0;
	
	csv.fromPath(path).on('record', function (data) {
		if (data[0] == 'position') {
			return; // skip header row
		}
		
		var entry = {
			id: null,
			imdbId: data[1],
			title: data[5],
			directors: data[7],
			rating: parseInt(data[8]) * 10,
			imdbRating: parseFloat(data[9]),
			runtime: isNaN(parseInt(data[10])) ? 0 : parseInt(data[10]),
			year: data[11],
			releaseDate: parseReleaseDate(data[14], data[5])
		}
		
		importQueue++;
		
		db.select('movies', { 'imdbId': entry.imdbId }, function (rows, fields) {
			if (rows.length) {
				that.emit('importQueueChanged', --importQueue);
			} else {
				db.insert('movies', entry, function (rows, fields) {
					that.emit('importQueueChanged', --importQueue);
				});
			}
		});
	}).on('end', function () {
		that.on('importQueueChanged', function (queueLength) {
			if (queueLength <= 0) {
				console.log('import complete');
				that.exit();
			}
		});
	});
}

MyFavoriteMovies.prototype.exit = function (code) {
	if (typeof(code) == 'undefined') {
		code = 0;
	}
	
	process.exit(code);
}

module.exports = MyFavoriteMovies;